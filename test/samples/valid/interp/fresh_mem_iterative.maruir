fun copy<M, M1>(src: u8[] *M, dst: u8[] *M1, nbytes: u32)
locals i: u32,
	  t: u8;
{
	entry:
		i := 0_u32;
		jump header;

	header:
		branch i < nbytes body exit;

	body:
		load src[i] in t;
		store t in dst[i];
		i := i + 1_u32;
		jump header;

	exit:
		return;
}

fun zerofill<'fresh M>(n: u32): u8[] *M
locals res: u8[] *M,
	   i: u32;
{
	entry:
		res := alloc u8[n] in M;
		i := 0_u32;
		jump header;

	header:
		branch i < n body exit;
	
	body:
		store 0_u8 in res[i];
		i := i + 1_u32;
		jump header;

	exit:
		return res;
}


fun repeat_zerofill<'fresh M>(n: u32): u8[] *M
locals res: u8[] *M,
	   t: u8[] *M1,
	   i: u32;
{
	entry:
		res := alloc u8[n] in M;
		i := 1_u32;
		jump header;

	header:
		branch i <= n body exit;
	
	body:
		t := call zerofill<out M1>(i);
		call copy<M1, M>(t, res, i);
		i := i + 1_u32;
		jump header;

	exit:
		return res;
}

fun main()
locals
	x: u8[] *M;
{
	entry:
		x := call repeat_zerofill<out M>(4_u32);
		return;
		
}
