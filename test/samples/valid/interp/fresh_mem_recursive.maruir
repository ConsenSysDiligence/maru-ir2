fun copy<M, M1>(src: u8[] *M, dst: u8[] *M1, nbytes: u32)
locals i: u32,
	  t: u8;
{
	entry:
		i := 0_u32;
		jump header;

	header:
		branch i < nbytes body exit;

	body:
		load src[i] in t;
		store t in dst[i];
		i := i + 1_u32;
		jump header;

	exit:
		return;
}

fun silly_zerofill<'fresh M>(n: u32): u8[] *M
locals res: u8[] *M,
	   t: u8[] *M1;
{
	entry:
		res := alloc u8[n] in M;
		branch n == 1_u32 base recursive;

	base:
		store 0_u8 in res[0_u32];
		return res;

	recursive:
		t := call silly_zerofill<out M1>(n - 1_u32);
		call copy<M1, M>(t, res, n - 1_u32);
		store 0_u8 in res[n - 1_u32];

		return res;
}

fun main()
locals
	x: u8[] *M;
{
	entry:
		x := call silly_zerofill<out M>(4_u32);
		return;
		
}
