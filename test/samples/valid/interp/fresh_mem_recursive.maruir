fun copy<M, M1>(src: u8[] *M, dst: u8[] *M1, nbytes: u32)
locals i: u32,
	  t: u8;
{
	entry:
		i := u32(0);
		jump header;

	header:
		branch i < nbytes body exit;

	body:
		load src[i] in t;
		store t in dst[i];
		i := i + u32(1);
		jump header;

	exit:
		return;
}

fun silly_zerofill<'fresh M>(n: u32): u8[] *M
locals res: u8[] *M,
	   t: u8[] *M1;
{
	entry:
		res := alloc u8[n] in M;
		branch n == u32(1) base recursive;

	base:
		store u8(0) in res[u32(0)];
		return res;

	recursive:
		t := call silly_zerofill<out M1>(n - u32(1));
		call copy<M1, M>(t, res, n - u32(1));
		store u8(0) in res[n - u32(1)];

		return res;
}

fun main()
locals
	x: u8[] *M;
{
	entry:
		x := call silly_zerofill<out M>(u32(4));
		return;
		
}
